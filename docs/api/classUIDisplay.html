<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UiUiUi: UIDisplay Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">UiUiUi
   </div>
   <div id="projectbrief">A user interface library for micro controller sketches based on U8g2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classUIDisplay-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">UIDisplay Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Representation of the display onto which UiUiUi renders its user interface.  
 <a href="classUIDisplay.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="UIDisplay_8h_source.html">UIDisplay.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for UIDisplay:</div>
<div class="dyncontent">
<div class="center"><img src="classUIDisplay__inherit__graph.png" border="0" usemap="#aUIDisplay_inherit__map" alt="Inheritance graph"/></div>
<map name="aUIDisplay_inherit__map" id="aUIDisplay_inherit__map">
<area shape="rect" title="Representation of the display onto which UiUiUi renders its user interface." alt="" coords="5,80,91,107"/>
<area shape="rect" href="classUIParent.html" title="Simple abstraction of elements which have at least one child." alt="" coords="9,5,87,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for UIDisplay:</div>
<div class="dyncontent">
<div class="center"><img src="classUIDisplay__coll__graph.png" border="0" usemap="#aUIDisplay_coll__map" alt="Collaboration graph"/></div>
<map name="aUIDisplay_coll__map" id="aUIDisplay_coll__map">
<area shape="rect" title="Representation of the display onto which UiUiUi renders its user interface." alt="" coords="5,80,91,107"/>
<area shape="rect" href="classUIParent.html" title="Simple abstraction of elements which have at least one child." alt="" coords="9,5,87,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a69b0398463d630e2b31415de27813a64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUIDisplay.html#a69b0398463d630e2b31415de27813a64">UIDisplay</a> (<a class="el" href="classUIWidget.html">UIWidget</a> *root)</td></tr>
<tr class="memdesc:a69b0398463d630e2b31415de27813a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the <a class="el" href="classUIDisplay.html" title="Representation of the display onto which UiUiUi renders its user interface.">UIDisplay</a> onto the given U8g2 instance and with the given root widget.  <a href="classUIDisplay.html#a69b0398463d630e2b31415de27813a64">More...</a><br /></td></tr>
<tr class="separator:a69b0398463d630e2b31415de27813a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7797b9c831714010a4c6639e0a29d982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUIDisplay.html#a7797b9c831714010a4c6639e0a29d982">init</a> (U8G2 *display, bool <a class="el" href="classUIDisplay.html#a087a02b48b00b463841740015ae5a7b2">enable</a>=true, bool <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945">render</a>=true)</td></tr>
<tr class="memdesc:a7797b9c831714010a4c6639e0a29d982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the whole user interface, layout the widgets.  <a href="classUIDisplay.html#a7797b9c831714010a4c6639e0a29d982">More...</a><br /></td></tr>
<tr class="separator:a7797b9c831714010a4c6639e0a29d982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010833082aba3c241378cf00221ccb68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUIDisplay.html#a010833082aba3c241378cf00221ccb68">setUpdateTiles</a> (uint16_t maxFirstUpdateTiles=0xffff, uint16_t maxFollowUpdateTiles=0xffff)</td></tr>
<tr class="memdesc:a010833082aba3c241378cf00221ccb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or changes the number of tiles to be sent to the display in one chunk.  <a href="classUIDisplay.html#a010833082aba3c241378cf00221ccb68">More...</a><br /></td></tr>
<tr class="separator:a010833082aba3c241378cf00221ccb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087a02b48b00b463841740015ae5a7b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUIDisplay.html#a087a02b48b00b463841740015ae5a7b2">enable</a> (U8G2 *display, bool <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945">render</a>=false, bool force=false)</td></tr>
<tr class="memdesc:a087a02b48b00b463841740015ae5a7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the UI: It presents itself on screen, display is turned on.  <a href="classUIDisplay.html#a087a02b48b00b463841740015ae5a7b2">More...</a><br /></td></tr>
<tr class="separator:a087a02b48b00b463841740015ae5a7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d1bd3a9c1c02457255ad305aa48f8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUIDisplay.html#ab7d1bd3a9c1c02457255ad305aa48f8f">disable</a> (U8G2 *display)</td></tr>
<tr class="memdesc:ab7d1bd3a9c1c02457255ad305aa48f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the UI: No rendering and display is switched to powersaving mode.  <a href="classUIDisplay.html#ab7d1bd3a9c1c02457255ad305aa48f8f">More...</a><br /></td></tr>
<tr class="separator:ab7d1bd3a9c1c02457255ad305aa48f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af662231a6dc1fbe05307ad5a3fea64cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUIDisplay.html#af662231a6dc1fbe05307ad5a3fea64cc">deactivate</a> ()</td></tr>
<tr class="memdesc:af662231a6dc1fbe05307ad5a3fea64cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivates the UI: It will be shown but no rendering will be performed.  <a href="classUIDisplay.html#af662231a6dc1fbe05307ad5a3fea64cc">More...</a><br /></td></tr>
<tr class="separator:af662231a6dc1fbe05307ad5a3fea64cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a45740e29438482d2f6a7febd2016e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUIDisplay.html#a4a45740e29438482d2f6a7febd2016e8">activate</a> ()</td></tr>
<tr class="memdesc:a4a45740e29438482d2f6a7febd2016e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates the UI: Rendering will be performed if <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> is called.  <a href="classUIDisplay.html#a4a45740e29438482d2f6a7febd2016e8">More...</a><br /></td></tr>
<tr class="separator:a4a45740e29438482d2f6a7febd2016e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50eb83c52dacff5d19dcbade92a9b03e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUIDisplay.html#a50eb83c52dacff5d19dcbade92a9b03e">childNeedsRendering</a> (<a class="el" href="classUIWidget.html">UIWidget</a> *child)</td></tr>
<tr class="memdesc:a50eb83c52dacff5d19dcbade92a9b03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the root widget to indicate that rendering must be performed.  <a href="classUIDisplay.html#a50eb83c52dacff5d19dcbade92a9b03e">More...</a><br /></td></tr>
<tr class="separator:a50eb83c52dacff5d19dcbade92a9b03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2131f4385ed0ed211412db2339ca4945"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945">render</a> (U8G2 *display, bool force=false)</td></tr>
<tr class="memdesc:a2131f4385ed0ed211412db2339ca4945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render the interface, update everything that has changed since the last <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> call.  <a href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945">More...</a><br /></td></tr>
<tr class="separator:a2131f4385ed0ed211412db2339ca4945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbe87a7a7bd8565a12d033f11021cbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUIDisplay.html#aabbe87a7a7bd8565a12d033f11021cbb">isUpdatingDisplay</a> ()</td></tr>
<tr class="memdesc:aabbe87a7a7bd8565a12d033f11021cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the UI is updating the display due to some earlier call to <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a>.  <a href="classUIDisplay.html#aabbe87a7a7bd8565a12d033f11021cbb">More...</a><br /></td></tr>
<tr class="separator:aabbe87a7a7bd8565a12d033f11021cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb810c16a19d101603cb7b8f80925552"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUIParent.html#afb810c16a19d101603cb7b8f80925552">childNeedsRendering</a> (<a class="el" href="classUIWidget.html">UIWidget</a> *child)=0</td></tr>
<tr class="memdesc:afb810c16a19d101603cb7b8f80925552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by any child of this group to indicate that it wants to be rendered.  <a href="classUIParent.html#afb810c16a19d101603cb7b8f80925552">More...</a><br /></td></tr>
<tr class="separator:afb810c16a19d101603cb7b8f80925552"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Representation of the display onto which UiUiUi renders its user interface. </p>
<p >This is always the topmost class of a UiUiUi interface. It gets gets one widget as parameter which gets the whole screen to render itself upon. Note that <a class="el" href="classUIDisplay.html" title="Representation of the display onto which UiUiUi renders its user interface.">UIDisplay</a> itself is NOT an <a class="el" href="classUIWidget.html" title="Basic widget class, ancestor of all UI widgets.">UIWidget</a>, but a <a class="el" href="classUIParent.html" title="Simple abstraction of elements which have at least one child.">UIParent</a> so it can be informed directly if anything has to be rendered at all.</p>
<p ><a class="el" href="classUIDisplay.html" title="Representation of the display onto which UiUiUi renders its user interface.">UIDisplay</a> converts any actual rendered area into tiles and sends only the changed tiles to the display. It is even possible to restrict the number of tiles sent at once - in this case, <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> must be called regulary by some background task. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a69b0398463d630e2b31415de27813a64" name="a69b0398463d630e2b31415de27813a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b0398463d630e2b31415de27813a64">&#9670;&nbsp;</a></span>UIDisplay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UIDisplay::UIDisplay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUIWidget.html">UIWidget</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup the <a class="el" href="classUIDisplay.html" title="Representation of the display onto which UiUiUi renders its user interface.">UIDisplay</a> onto the given U8g2 instance and with the given root widget. </p>
<p >If doSendBuffer is true, <a class="el" href="classUIDisplay.html" title="Representation of the display onto which UiUiUi renders its user interface.">UIDisplay</a> sends always the complete buffer to the display if any changes happened during rendering. Use this if updates of areas do not work on your display. Normally, this should be false.</p>
<p >In event-driven setups you may want to restrict the number of operations (and therefore the time spent) in <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a>. To allow this, you can give a maximum number of tiles sent to the display in the <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> call where that actual rendering took place and the maximum number of tiles sent in subsequent calls to <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a>.</p>
<p >Note that <a class="el" href="classUIDisplay.html" title="Representation of the display onto which UiUiUi renders its user interface.">UIDisplay</a> will in follow cycles <em>always</em> send at least one complete row or column of tiles to the display. So, if you specify "2" as maximum number of tiles but the area to send is "5x3" tiles, actually three tiles will be sent. So, on a 128x64 display, the "maximum minimum" amount of tiles sent at once will always be 8 (64/8).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The root widget which will get the whole display to render on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4a45740e29438482d2f6a7febd2016e8" name="a4a45740e29438482d2f6a7febd2016e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a45740e29438482d2f6a7febd2016e8">&#9670;&nbsp;</a></span>activate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UIDisplay::activate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activates the UI: Rendering will be performed if <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> is called. </p>
<p >This is the counterpart to <a class="el" href="classUIDisplay.html#af662231a6dc1fbe05307ad5a3fea64cc" title="Deactivates the UI: It will be shown but no rendering will be performed.">deactivate()</a>. Rendering of the UI will resume. Note that this method does <em>not</em> call <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> internally.</p>
<p >This method, as <a class="el" href="classUIDisplay.html#af662231a6dc1fbe05307ad5a3fea64cc" title="Deactivates the UI: It will be shown but no rendering will be performed.">deactivate()</a>, will normally be used in asynchronous setups where <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> is called regulary in the background. After <a class="el" href="classUIDisplay.html#a4a45740e29438482d2f6a7febd2016e8" title="Activates the UI: Rendering will be performed if render() is called.">activate()</a>, the next <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> call will be performed anyway and resume the usual interface updates. </p>

</div>
</div>
<a id="a50eb83c52dacff5d19dcbade92a9b03e" name="a50eb83c52dacff5d19dcbade92a9b03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50eb83c52dacff5d19dcbade92a9b03e">&#9670;&nbsp;</a></span>childNeedsRendering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UIDisplay::childNeedsRendering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUIWidget.html">UIWidget</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by the root widget to indicate that rendering must be performed. </p>

<p>Implements <a class="el" href="classUIParent.html#afb810c16a19d101603cb7b8f80925552">UIParent</a>.</p>

</div>
</div>
<a id="af662231a6dc1fbe05307ad5a3fea64cc" name="af662231a6dc1fbe05307ad5a3fea64cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af662231a6dc1fbe05307ad5a3fea64cc">&#9670;&nbsp;</a></span>deactivate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UIDisplay::deactivate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deactivates the UI: It will be shown but no rendering will be performed. </p>
<p >Calling this method disables the <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> process completely. Calling <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> will return in almost no time. The display will simply stay frozen until <a class="el" href="classUIDisplay.html#a4a45740e29438482d2f6a7febd2016e8" title="Activates the UI: Rendering will be performed if render() is called.">activate()</a> is called.</p>
<p >Calling this method makes sense is rendering is performed by a background task which is executed regulary and there are time-critical processes ongoing which prevent a normal <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> run.</p>
<p >If you draw the UI synchronously, i.e. by directly calling <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> in loop() or so, it often makes more sense to simply not call <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> during such processes. </p>

</div>
</div>
<a id="ab7d1bd3a9c1c02457255ad305aa48f8f" name="ab7d1bd3a9c1c02457255ad305aa48f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d1bd3a9c1c02457255ad305aa48f8f">&#9670;&nbsp;</a></span>disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UIDisplay::disable </td>
          <td>(</td>
          <td class="paramtype">U8G2 *&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the UI: No rendering and display is switched to powersaving mode. </p>
<p >Disables the UI: No rendering and display is turned off.</p>
<p >Usually, the display will be switched off after this call while its memory contents are preserved. If the display is disabled this way, <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> will not perform any actions and will be very fast. That's important if the interface is updated asynchronously in the background.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>U8g2 display to render on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a087a02b48b00b463841740015ae5a7b2" name="a087a02b48b00b463841740015ae5a7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087a02b48b00b463841740015ae5a7b2">&#9670;&nbsp;</a></span>enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UIDisplay::enable </td>
          <td>(</td>
          <td class="paramtype">U8G2 *&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>render</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the UI: It presents itself on screen, display is turned on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>U8g2 display to work on </td></tr>
    <tr><td class="paramname">render</td><td>If true, renders the display explicitly on enabling, if false, not. Default is false. </td></tr>
    <tr><td class="paramname">force</td><td>If true, forces rendering to a complete re-render, otherwise normal rendering. Default is false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7797b9c831714010a4c6639e0a29d982" name="a7797b9c831714010a4c6639e0a29d982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7797b9c831714010a4c6639e0a29d982">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UIDisplay::init </td>
          <td>(</td>
          <td class="paramtype">U8G2 *&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>render</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the whole user interface, layout the widgets. </p>
<p >Initializing the UI normally implies the initial rendering. This can be suppressed by setting "render" to false. Then, however the sketch has to call render(&amp;display,true) itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>U8g2 display to work on </td></tr>
    <tr><td class="paramname">enable</td><td>If true, explicitly enables the display, false if not. Default is true. </td></tr>
    <tr><td class="paramname">render</td><td>If true, performs initial rendering, otherwise not. Default is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabbe87a7a7bd8565a12d033f11021cbb" name="aabbe87a7a7bd8565a12d033f11021cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbe87a7a7bd8565a12d033f11021cbb">&#9670;&nbsp;</a></span>isUpdatingDisplay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UIDisplay::isUpdatingDisplay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the UI is updating the display due to some earlier call to <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a>. </p>
<p >This method only makes sense if the number of updated tiles is limited and display updates could be split into several calls of <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a>. Then, this method returns true if such delayed updates are still vacant. If not, it returns false. This also means that calls to <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> will return almost immediately. </p>

</div>
</div>
<a id="a2131f4385ed0ed211412db2339ca4945" name="a2131f4385ed0ed211412db2339ca4945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2131f4385ed0ed211412db2339ca4945">&#9670;&nbsp;</a></span>render()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UIDisplay::render </td>
          <td>(</td>
          <td class="paramtype">U8G2 *&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render the interface, update everything that has changed since the last <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> call. </p>
<p >Rendering is performed by calling the <a class="el" href="classUIDisplay.html#a2131f4385ed0ed211412db2339ca4945" title="Render the interface, update everything that has changed since the last render() call.">render()</a> method of every widget in the UI which is currently visible (<a class="el" href="classUICards.html" title="Widget group which shows nothing or exactly one of its sub-widgets.">UICards</a> being the the widget group which can render a widget invisible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>U8g2 display to render upon </td></tr>
    <tr><td class="paramname">force</td><td>Flag whether a complete rendering should take place (true) or only the parts are updated which need a redraw (false). Default is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a010833082aba3c241378cf00221ccb68" name="a010833082aba3c241378cf00221ccb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010833082aba3c241378cf00221ccb68">&#9670;&nbsp;</a></span>setUpdateTiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UIDisplay::setUpdateTiles </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>maxFirstUpdateTiles</em> = <code>0xffff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>maxFollowUpdateTiles</em> = <code>0xffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or changes the number of tiles to be sent to the display in one chunk. </p>
<p >Set this to a small value to prevent longer pauses of execution due to communication with the display, especially if it has a slow serial connection.</p>
<p >These values may be changed during sketch execution, even during a running rendering process. They are effective immediately.</p>
<p >If this method is not called or if it is called without parameters, the maximum number of tiles is set to "unlimited" (0xffff). In this case, all needed tiles are sent to the screen immediately after rendering. This may need several 100 milliseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxFirstUpdateTiles</td><td>Maximum number of tiles updated at once together with rendering </td></tr>
    <tr><td class="paramname">maxFollowUpdateTiles</td><td>Maximum number of tiles updated at once if no rendering happens </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="UIDisplay_8h_source.html">UIDisplay.h</a></li>
<li>src/UIDisplay.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
